# Task 4 Completion: Implement Web Platform (Shadow DOM)

**Date**: November 30, 2025
**Task**: 4. Implement Web Platform (Shadow DOM)
**Type**: Parent
**Status**: Complete

---

## Artifacts Created

### Primary Artifacts

- `src/components/core/Container/platforms/web/Container.web.tsx` - Web component implementation with Shadow DOM
- `src/components/core/Container/platforms/web/token-mapping.ts` - Token-to-CSS mapping functions
- `src/components/core/Container/platforms/web/styles.css` - Component base styles and responsive behavior
- `src/components/core/Container/platforms/web/__tests__/Container.web.test.ts` - Web component tests
- `src/components/core/Container/platforms/web/__tests__/token-mapping.test.ts` - Token mapping tests

### Supporting Files

All files created during subtasks 4.1-4.5 are integrated into the primary artifacts above.

---

## Implementation Details

### Web Component Architecture

The Container web component follows the Custom Elements v1 specification with Shadow DOM for style encapsulation. The implementation provides:

**Shadow DOM Encapsulation**:
- Open shadow root for accessibility and debugging
- Style isolation prevents external CSS from affecting component
- Slot-based content projection for child elements

**Observed Attributes Pattern**:
- All Container props exposed as HTML attributes
- Automatic re-rendering when attributes change
- Type-safe attribute reading with proper type casting

**Semantic HTML Support**:
- Dynamic element creation based on `semantic` attribute
- Supports: div, section, article, aside, nav, header, footer, main, fieldset
- Defaults to div when semantic attribute not provided

### Token-to-CSS Mapping Strategy

The token mapping system converts platform-agnostic token references to CSS custom properties:

**Conversion Pattern**:
```typescript
// Input: 'space.inset.200' (dot notation)
// Output: 'var(--space-inset-200)' (CSS custom property)
```

**Mapping Functions**:
- `tokenToCssVar()` - Core conversion function (dot notation → CSS var)
- `mapPaddingToCSS()` - Padding token → CSS padding property
- `mapBorderToCSS()` - Border token → CSS border property (width + color)
- `mapBorderRadiusToCSS()` - Border radius token → CSS border-radius property
- `mapColorToCSS()` - Color token → CSS background property
- `mapShadowToCSS()` - Shadow token → CSS box-shadow property
- `mapOpacityToCSS()` - Opacity token → CSS opacity property
- `mapLayeringToCSS()` - Layering value → CSS z-index property (web uses z-index tokens)

**Build System Integration**:
The mapping functions reference CSS custom properties that are generated by the build system from semantic tokens. This ensures:
- Mathematical consistency across platforms
- Single source of truth for token values
- Platform-specific unit conversion (px for web)

### Accessibility Implementation

**ARIA Label Support**:
- `accessibility-label` attribute maps to `aria-label` on inner element
- HTML escaping prevents XSS attacks in accessibility labels
- No aria-label applied when attribute not provided

**Focus Management**:
- Focus styles use `:focus-visible` for keyboard navigation
- Mouse clicks don't show focus outline (better UX)
- Keyboard navigation shows clear focus indicator
- Focus outline uses `color.primary` token for consistency

**Reduced Motion Support**:
- Respects `prefers-reduced-motion` media query
- Disables all transitions and animations when user prefers reduced motion
- Ensures accessibility for users with vestibular disorders

**High Contrast Mode**:
- Increases border width in high contrast mode
- Ensures visual structure remains clear
- Respects `prefers-contrast: high` media query

### Responsive Behavior

The styles.css file includes responsive breakpoints with documentation:

**Breakpoints**:
- Small screens (≤640px): Mobile devices
- Medium screens (641px-1024px): Tablets
- Large screens (≥1025px): Desktop

**Token-Based Spacing**:
Responsive adjustments are achieved through different padding prop values rather than CSS overrides:
- Mobile: Use `padding="100"` (8px) for tighter spacing
- Tablet: Use default values
- Desktop: Use `padding="300"` (24px) or `padding="400"` (32px) for generous spacing

This approach maintains token-based mathematical relationships across all breakpoints.

### Print Optimization

**Print Styles**:
- Removes box-shadow (doesn't print well)
- Ensures backgrounds print with `print-color-adjust: exact`
- Optimizes appearance for print media

---

## Architecture Decisions

### Decision 1: Shadow DOM vs Light DOM

**Options Considered**:
1. Shadow DOM with style encapsulation
2. Light DOM with scoped styles
3. Light DOM with BEM naming convention

**Decision**: Shadow DOM with open mode

**Rationale**:
- **Style Encapsulation**: Prevents external CSS from affecting component, ensuring consistent appearance
- **Slot-Based Content**: Clean content projection pattern for child elements
- **Open Mode**: Allows accessibility tools and debugging while maintaining encapsulation
- **Web Standards**: Uses native browser capabilities without polyfills

**Trade-offs**:
- ✅ **Gained**: Style isolation, clean API, standards-based approach
- ❌ **Lost**: Some flexibility in styling from outside (intentional)
- ⚠️ **Risk**: Shadow DOM has some browser quirks, but well-supported in modern browsers

### Decision 2: Inline Styles vs Style Element

**Options Considered**:
1. Inline styles on element (style attribute)
2. Style element in Shadow DOM
3. Constructable stylesheets

**Decision**: Style element in Shadow DOM

**Rationale**:
- **Readability**: Styles are organized and readable in style element
- **Performance**: Browser can optimize style element better than inline styles
- **Maintainability**: Easier to debug and modify styles
- **Base Styles**: Allows combining base styles with token-based styles

**Trade-offs**:
- ✅ **Gained**: Better organization, performance, maintainability
- ❌ **Lost**: Slightly more complex rendering logic
- ⚠️ **Risk**: None - this is the standard pattern for web components

### Decision 3: Token Mapping in Component vs Separate Module

**Options Considered**:
1. Token mapping functions in Container.web.tsx
2. Separate token-mapping.ts module
3. Shared token mapping across all components

**Decision**: Separate token-mapping.ts module

**Rationale**:
- **Separation of Concerns**: Component focuses on rendering, mapping focuses on token conversion
- **Testability**: Token mapping can be tested independently
- **Reusability**: Other web components can use the same mapping functions
- **Maintainability**: Changes to mapping logic don't affect component structure

**Trade-offs**:
- ✅ **Gained**: Better organization, testability, reusability
- ❌ **Lost**: Slightly more files to manage
- ⚠️ **Risk**: None - this is a standard modular architecture pattern

### Decision 4: Semantic HTML Element Selection

**Options Considered**:
1. Always render as div
2. Semantic attribute controls element type
3. Automatic semantic detection based on content

**Decision**: Semantic attribute controls element type

**Rationale**:
- **Developer Control**: Developers explicitly choose semantic element
- **Accessibility**: Enables proper semantic HTML structure
- **Flexibility**: Supports all common semantic elements
- **Predictability**: No magic behavior, explicit attribute controls output

**Trade-offs**:
- ✅ **Gained**: Developer control, accessibility, flexibility
- ❌ **Lost**: Automatic semantic detection (would be too complex)
- ⚠️ **Risk**: Developers might not use semantic elements (documentation addresses this)

---

## Validation (Tier 3: Comprehensive - Parent Task)

### Syntax Validation
✅ getDiagnostics passed - no TypeScript errors in Container.web.tsx
✅ getDiagnostics passed - no TypeScript errors in token-mapping.ts
✅ CSS has intentional empty rulesets (documentation placeholders)
✅ All imports resolve correctly
✅ Type annotations correct throughout

### Functional Validation
✅ Container renders as web component with Shadow DOM
✅ Shadow DOM attached in open mode
✅ Slot renders for child content
✅ All observed attributes defined correctly
✅ Semantic HTML elements work (div, section, article, aside, nav, header, footer, main, fieldset)
✅ Default to div when semantic attribute not provided
✅ Accessibility labels applied as aria-label
✅ HTML escaping prevents XSS in accessibility labels
✅ All token-to-CSS mapping functions work correctly
✅ Padding, background, shadow, border, borderRadius, opacity, layering all map correctly

### Design Validation
✅ Shadow DOM provides style encapsulation
✅ Token mapping maintains separation of concerns
✅ Component focuses on rendering, mapping focuses on conversion
✅ Semantic HTML support enables accessibility
✅ Responsive behavior uses token-based spacing
✅ Print optimization improves print output
✅ Reduced motion support respects user preferences
✅ High contrast mode maintains visual structure

### System Integration
✅ Integrates with token system via CSS custom properties
✅ Token references follow dot notation convention
✅ CSS custom properties generated by build system
✅ Platform-specific unit conversion (px for web)
✅ Component tokens file provides token references
✅ Type system ensures type safety for all props

### Edge Cases
✅ Handles missing attributes gracefully (no styles applied)
✅ Handles 'none' values correctly (no styles applied)
✅ Handles invalid token names gracefully (no styles applied)
✅ HTML escaping prevents XSS attacks
✅ Re-renders when attributes change
✅ Custom element registration prevents duplicate registration

### Subtask Integration
✅ Task 4.1 (web component class) - Complete and integrated
✅ Task 4.2 (token-to-CSS mapping) - Complete and integrated
✅ Task 4.3 (semantic HTML) - Complete and integrated
✅ Task 4.4 (accessibility) - Complete and integrated
✅ Task 4.5 (component styles) - Complete and integrated

### Success Criteria Verification

#### Criterion 1: Container renders as web component with Shadow DOM encapsulation

**Evidence**: Container.web.tsx implements Custom Element with Shadow DOM attachment

**Verification**:
- Shadow DOM attached in constructor with open mode
- Style encapsulation prevents external CSS interference
- Slot-based content projection works correctly
- Tests verify Shadow DOM presence and mode

**Example**:
```typescript
constructor() {
  super();
  this._shadowRoot = this.attachShadow({ mode: 'open' });
}
```

#### Criterion 2: All props map correctly to CSS properties

**Evidence**: token-mapping.ts provides comprehensive mapping functions for all props

**Verification**:
- Padding maps to CSS padding via space.inset tokens
- Background maps to CSS background via color tokens
- Shadow maps to CSS box-shadow via shadow tokens
- Border maps to CSS border via border tokens + color.border
- BorderRadius maps to CSS border-radius via radius tokens
- Opacity maps to CSS opacity via opacity tokens
- Layering maps to CSS z-index via zIndex tokens (web platform)
- Tests verify all mapping functions work correctly

**Example**:
```typescript
mapPaddingToCSS('200') // Returns 'padding: var(--space-inset-200)'
mapColorToCSS('color.surface') // Returns 'background: var(--color-surface)'
```

#### Criterion 3: Semantic HTML elements work

**Evidence**: Container.web.tsx supports all required semantic elements

**Verification**:
- Supports: div, section, article, aside, nav, header, footer, main, fieldset
- Defaults to div when semantic attribute not provided
- Dynamic element creation based on semantic attribute
- Tests verify all semantic elements render correctly

**Example**:
```html
<dp-container semantic="article">Content</dp-container>
<!-- Renders as <article class="container">Content</article> inside Shadow DOM -->
```

#### Criterion 4: Token-to-CSS mapping functions correctly

**Evidence**: token-mapping.ts provides robust token conversion

**Verification**:
- tokenToCssVar() converts dot notation to CSS custom properties
- All mapping functions use tokenToCssVar() for consistency
- CSS custom properties reference build system generated tokens
- Mathematical relationships preserved through token system
- Tests verify token conversion accuracy

**Example**:
```typescript
tokenToCssVar('space.inset.200') // Returns 'var(--space-inset-200)'
// Build system generates: --space-inset-200: 16px
```

#### Criterion 5: Accessibility labels applied properly

**Evidence**: Container.web.tsx applies aria-label when accessibility-label attribute provided

**Verification**:
- accessibility-label attribute maps to aria-label on inner element
- HTML escaping prevents XSS attacks
- No aria-label when attribute not provided
- Tests verify aria-label application and XSS prevention

**Example**:
```html
<dp-container accessibility-label="Main content">Content</dp-container>
<!-- Renders with aria-label="Main content" on inner element -->
```

### End-to-End Functionality
✅ Complete workflow: Attributes → Token mapping → CSS styles → Rendered component
✅ Cross-platform consistency: Token references work with build system
✅ Accessibility: ARIA labels, focus management, reduced motion, high contrast
✅ Responsive: Token-based spacing adapts to different screen sizes
✅ Print: Optimized for print media

### Requirements Coverage
✅ Requirement 10.1: Web implementation uses web components with Shadow DOM
✅ Requirement 11.1: Shadow DOM provides style encapsulation
✅ Requirement 11.2: Observed attributes trigger re-rendering
✅ Requirement 11.3: Semantic HTML element selection works
✅ Requirement 11.4: Defaults to div when semantic not provided
✅ Requirement 11.5-11.8: All semantic elements supported
✅ Requirement 14.1: Accessibility label support implemented
✅ Requirement 14.2: aria-label applied on web platform
✅ Requirements 2.1-2.5: All token-to-CSS mappings implemented
✅ Requirements 3.1-3.7: Padding mapping works correctly
✅ Requirements 4.1-4.4: Background mapping works correctly
✅ Requirements 5.1-5.4: Shadow mapping works correctly
✅ Requirements 6.1-6.5: Border mapping works correctly
✅ Requirements 7.1-7.4: Border radius mapping works correctly
✅ Requirements 8.1-8.4: Opacity mapping works correctly
✅ Requirements 9.1-9.9: Layering mapping works correctly (z-index for web)

---

## Requirements Compliance

### Core Requirements

**Requirement 10.1**: Container implemented for web using web components with Shadow DOM
- ✅ Custom Element class extends HTMLElement
- ✅ Shadow DOM attached in constructor
- ✅ Registered as 'dp-container' custom element

**Requirement 11.1**: Shadow DOM provides style encapsulation
- ✅ Open shadow root attached
- ✅ Styles isolated from external CSS
- ✅ Slot-based content projection

**Requirement 11.2**: Observed attributes trigger re-rendering
- ✅ observedAttributes static getter defined
- ✅ attributeChangedCallback implemented
- ✅ Re-renders when attributes change

**Requirement 11.3**: Semantic HTML element selection
- ✅ semantic attribute controls element type
- ✅ Dynamic element creation in render()

**Requirement 11.4**: Defaults to div when semantic not provided
- ✅ Default value: `const semantic = this.getAttribute('semantic') || 'div'`

**Requirements 11.5-11.8**: All semantic elements supported
- ✅ div, section, article, aside, nav, header, footer, main, fieldset

**Requirement 14.1**: Accessibility label support
- ✅ accessibility-label attribute supported
- ✅ Maps to aria-label on inner element

**Requirement 14.2**: aria-label applied on web platform
- ✅ Applied when accessibility-label provided
- ✅ HTML escaping prevents XSS

### Token Mapping Requirements

**Requirements 2.1-2.5**: Token-based styling
- ✅ All styling references design system tokens
- ✅ No hard-coded values in component
- ✅ CSS custom properties generated by build system

**Requirements 3.1-3.7**: Padding capability
- ✅ Padding values map to space.inset tokens
- ✅ 'none' value supported (no padding)
- ✅ All padding values (050, 100, 150, 200, 300, 400) supported

**Requirements 4.1-4.4**: Background capability
- ✅ Background maps to color tokens
- ✅ 'none' value supported (no background)
- ✅ All color token names accepted

**Requirements 5.1-5.4**: Shadow capability
- ✅ Shadow maps to shadow tokens
- ✅ 'none' value supported (no shadow)
- ✅ All shadow token names accepted

**Requirements 6.1-6.5**: Border capability
- ✅ Border maps to border tokens
- ✅ Border color uses color.border token
- ✅ 'none' value supported (no border)
- ✅ All border values (default, emphasis, heavy) supported

**Requirements 7.1-7.4**: Border radius capability
- ✅ Border radius maps to radius tokens
- ✅ 'none' value supported (no border radius)
- ✅ All border radius values (tight, normal, loose) supported

**Requirements 8.1-8.4**: Opacity capability
- ✅ Opacity maps to opacity tokens
- ✅ 'none' value supported (full opacity)
- ✅ All opacity token names accepted

**Requirements 9.1-9.9**: Layering capability
- ✅ Layering maps to z-index tokens on web
- ✅ All layering values (container, navigation, dropdown, modal, toast, tooltip) supported
- ✅ Platform-specific token mapping (web uses zIndex tokens)

---

## Lessons Learned

### What Worked Well

**Shadow DOM Encapsulation**:
- Style isolation works perfectly for component-based architecture
- Open mode provides good balance of encapsulation and accessibility
- Slot-based content projection is clean and intuitive

**Token Mapping Architecture**:
- Separate module for token mapping improves testability
- tokenToCssVar() function provides consistent conversion
- CSS custom properties integrate seamlessly with build system

**Semantic HTML Support**:
- Dynamic element creation is straightforward
- Provides good accessibility foundation
- Developer control over semantic structure

**Comprehensive Testing**:
- Tests cover all functionality thoroughly
- Shadow DOM testing is straightforward with Jest
- Token mapping tests validate conversion accuracy

### Challenges

**CSS Custom Property Naming**:
- Converting dot notation to CSS custom properties requires careful handling
- Ensured consistency with build system generated names
- **Resolution**: tokenToCssVar() function handles conversion reliably

**Attribute Change Detection**:
- Need to avoid unnecessary re-renders when attribute doesn't actually change
- **Resolution**: Check oldValue !== newValue in attributeChangedCallback

**HTML Escaping**:
- Accessibility labels need XSS protection
- **Resolution**: Use textContent → innerHTML pattern for safe escaping

**Empty CSS Rulesets**:
- Media query placeholders trigger CSS linter warnings
- **Resolution**: Warnings are intentional, rulesets are documentation

### Future Considerations

**Constructable Stylesheets**:
- Could improve performance for multiple instances
- Not critical for current implementation
- Consider if performance becomes an issue

**CSS Shadow Parts**:
- Could allow limited external styling via ::part()
- Not needed for current requirements
- Consider if external styling flexibility is needed

**Declarative Shadow DOM**:
- Could improve SSR support
- Not needed for current client-side implementation
- Consider if SSR becomes a requirement

---

## Integration Points

### Dependencies

**Token System**:
- Depends on component tokens file (tokens.ts) for token references
- Depends on build system for CSS custom property generation
- Depends on semantic tokens for token values

**Type System**:
- Depends on generated TokenTypes for ColorTokenName, ShadowTokenName, OpacityTokenName
- Depends on component types for PaddingValue, BorderValue, etc.

**Build System**:
- Depends on build system to generate CSS custom properties from tokens
- CSS custom properties must match token names (dot notation → kebab-case)

### Dependents

**Container Component**:
- Web implementation is one of three platform implementations
- iOS and Android implementations will follow similar patterns
- All platforms share the same token references

**Semantic Components**:
- Card, Panel, Hero will use Container as foundation
- Web implementations of semantic components will use dp-container element

**Documentation**:
- README will reference web component usage
- Examples will demonstrate web component API

### Extension Points

**Additional Semantic Elements**:
- Can add more semantic elements by updating SemanticHTMLElement type
- No changes needed to component logic

**Additional Token Mappings**:
- Can add new token types by adding mapping functions
- Follow existing pattern: mapXToCSS() function

**Custom Styling**:
- Could add CSS Shadow Parts for limited external styling
- Would require adding part attributes to inner elements

### API Surface

**Custom Element**:
- `<dp-container>` - Custom element tag name
- Attributes: padding, background, shadow, border, border-radius, opacity, layering, semantic, accessibility-label

**Token Mapping Functions** (exported from token-mapping.ts):
- `tokenToCssVar(tokenName: string): string`
- `mapPaddingToCSS(padding: PaddingValue | null): string`
- `mapBorderToCSS(border: BorderValue | null): string`
- `mapBorderRadiusToCSS(borderRadius: BorderRadiusValue | null): string`
- `mapColorToCSS(color: ColorTokenName | null): string`
- `mapShadowToCSS(shadow: ShadowTokenName | null): string`
- `mapOpacityToCSS(opacity: OpacityTokenName | null): string`
- `mapLayeringToCSS(layering: LayeringValue | null): string`
- `buildContainerStyles(props: {...}): string`

**Component Class** (exported from Container.web.tsx):
- `ContainerWeb` - Custom element class
- `observedAttributes` - Static getter for observed attributes

---

## Related Documentation

- [Task 4 Summary](../../../../docs/specs/010-container-component/task-4-summary.md) - Public-facing summary that triggered release detection
- [Requirements Document](../../requirements.md) - Complete requirements for Container component
- [Design Document](../../design.md) - Complete design for Container component
- [Component Tokens](../../tokens.ts) - Platform-agnostic token references

---

**Organization**: spec-completion
**Scope**: 010-container-component
