# Rosetta System Unit Handling Investigation

**Date**: December 11, 2025  
**Purpose**: Investigate unit handling in the Rosetta system and verify alignment with original vision  
**Organization**: spec-validation  
**Scope**: 019-test-failures-and-cleanup

---

## Investigation Summary

Your Rosetta vision is **CORRECT**. The build system is working as intended. The issue is in component development, not the build system.

## Build System Analysis (✅ Correct)

### UnitConverter.ts

The `UnitConverter` class correctly returns `PlatformValue` objects that include both `value` and `unit`:

```typescript
export interface PlatformValue {
  value: number;
  unit: PlatformUnit;
  token: string;
}
```

**Key Methods**:
- `convertToiOS()`: Returns `{ value: 8, unit: 'pt', token: 'space100' }`
- `convertToAndroid()`: Returns `{ value: 8, unit: 'dp', token: 'space100' }`
- `convertToWeb()`: Returns `{ value: 8, unit: 'px', token: 'space100' }`

### AndroidBuilder.ts

The Android builder correctly generates token constants **with units included**:

```kotlin
// Generated by AndroidBuilder.ts
val space100: Dp = 8.dp
val space_inset_100: Dp = 8.dp
val border_default: Dp = 1.dp
val radius_100: Dp = 8.dp
```

**Key Point**: The build system adds `.dp` to the value when generating the constant.

### iOSBuilder.ts

The iOS builder correctly generates token constants as **unitless CGFloat values**:

```swift
// Generated by iOSBuilder.ts
public static let space100: CGFloat = 8
public static let space_inset_100: CGFloat = 8
public static let border_default: CGFloat = 1
public static let radius_100: CGFloat = 8
```

**Key Point**: CGFloat is unitless in Swift. SwiftUI modifiers handle unit conversion internally.

### WebBuilder.ts

The Web builder correctly generates CSS custom properties **with units included**:

```css
/* Generated by WebBuilder.ts */
--space-100: 8px;
--space-inset-100: 8px;
--border-default: 1px;
--radius-100: 8px;
```

**Key Point**: CSS custom properties include the unit in the value.

## Component Development Analysis (❌ Incorrect)

### Current Pattern (Wrong)

Android components are manually adding `.dp` when referencing generated constants:

```kotlin
// From Container/TokenMapping.kt
private val spaceInset100: Dp = DesignTokens.space_inset_100.dp  // ❌ WRONG
private val borderDefault: Dp = DesignTokens.border_default.dp   // ❌ WRONG
private val radius100: Dp = DesignTokens.radius_100.dp           // ❌ WRONG
```

**Problem**: The build system already generates `val space_inset_100: Dp = 8.dp`, so adding `.dp` again is redundant and incorrect.

### Correct Pattern

Components should reference the generated constants directly:

```kotlin
// ✅ CORRECT
private val spaceInset100: Dp = DesignTokens.space_inset_100
private val borderDefault: Dp = DesignTokens.border_default
private val radius100: Dp = DesignTokens.radius_100
```

**Why**: The build system already includes the unit in the generated constant.

## Root Cause

Component development deviated from the Rosetta vision. The pattern of manually adding units was established during component development, likely because:

1. Developers weren't aware that the build system already includes units
2. The Component Development Guide didn't clearly document the Rosetta pattern
3. Early component examples set the wrong pattern, which was then copied

## Rosetta Vision Validation

Your original vision is **100% correct**:

> "Components would only need to reference the token (without unit), and the token would render the appropriate unit for the appropriate platform if a unit was applicable."

**This is exactly what the build system does**:
- Components reference: `DesignTokens.space100`
- Build system generates: `val space100: Dp = 8.dp` (Android)
- Build system generates: `public static let space100: CGFloat = 8` (iOS)
- Build system generates: `--space-100: 8px;` (Web)

The build system handles unit application. Components just reference the token.

## Fix Strategy

### 1. Document Correct Pattern

Update Component Development Guide to clearly document the Rosetta pattern:

```markdown
## Rosetta System: Unit Handling

**Components reference tokens WITHOUT units. The build system applies units.**

### Android
```kotlin
// ✅ CORRECT
val padding = DesignTokens.space_inset_100  // Build system generates: val space_inset_100: Dp = 8.dp

// ❌ WRONG
val padding = DesignTokens.space_inset_100.dp  // Redundant - unit already included
```

### iOS
```swift
// ✅ CORRECT
let padding = Tokens.Space.space100  // Build system generates: public static let space100: CGFloat = 8

// ❌ WRONG
// CGFloat is unitless - no unit addition needed
```

### Web
```css
/* ✅ CORRECT */
padding: var(--space-inset-100);  /* Build system generates: --space-inset-100: 8px; */

/* ❌ WRONG */
/* Don't add units - already included in custom property */
```
```

### 2. Fix Android Components

Remove manual `.dp` additions from all Android component implementations:

**Files to Fix**:
- `src/components/core/Container/platforms/android/TokenMapping.kt`
- `src/components/core/ButtonCTA/platforms/android/ButtonCTA.android.kt`
- `src/components/core/Icon/platforms/android/Icon.android.kt`
- `src/components/core/TextInputField/platforms/android/TextInputField.android.kt`

**Pattern**:
```kotlin
// Before (wrong)
private val spaceInset100: Dp = DesignTokens.space_inset_100.dp

// After (correct)
private val spaceInset100: Dp = DesignTokens.space_inset_100
```

### 3. Verify iOS Components

Check that iOS components are correctly using unitless CGFloat values:

**Files to Check**:
- `src/components/core/Container/platforms/ios/Container.ios.swift`
- `src/components/core/ButtonCTA/platforms/ios/ButtonCTA.ios.swift`
- `src/components/core/Icon/platforms/ios/Icon.ios.swift`
- `src/components/core/TextInputField/platforms/ios/TextInputField.ios.swift`

**Expected Pattern**:
```swift
// ✅ CORRECT
let padding = Tokens.Space.space100  // CGFloat is unitless
```

### 4. Verify Web Components

Check that Web components are correctly using CSS custom properties with units:

**Files to Check**:
- `src/components/core/Container/platforms/web/Container.web.ts`
- `src/components/core/ButtonCTA/platforms/web/ButtonCTA.web.ts`
- `src/components/core/Icon/platforms/web/Icon.web.ts`
- `src/components/core/TextInputField/platforms/web/TextInputField.web.ts`

**Expected Pattern**:
```css
/* ✅ CORRECT */
padding: var(--space-inset-100);  /* Unit already included */
```

## Conclusion

The Rosetta system is working correctly. The build system applies units appropriately for each platform. Component development needs to be corrected to follow the Rosetta pattern: **reference tokens without units, let the build system handle unit application**.

This investigation validates your original vision and confirms that the build system implementation is correct.

---

**Next Steps**: Update Task 4 subtasks to reflect this understanding and focus on fixing component implementations rather than investigating the build system.
