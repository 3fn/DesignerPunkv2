/**
 * Visual State Styles for Button-VerticalListItem (Android Platform)
 * 
 * Defines the visual state mapping and error styling logic for the
 * VerticalListButtonItem component on Android.
 * 
 * This file implements the state-to-style mapping that matches the TypeScript
 * definition in the web implementation, ensuring cross-platform consistency.
 * 
 * RTL Support (Requirements: 11.5, 11.7):
 * The visual styles defined here are direction-agnostic. RTL layout adaptation
 * is handled automatically by Compose's layout system in VerticalListButtonItem.kt.
 * The Row composable with Arrangement.spacedBy automatically reverses the
 * horizontal arrangement in RTL mode, so:
 * - In LTR: [Leading Icon] [Content] [Checkmark]
 * - In RTL: [Checkmark] [Content] [Leading Icon]
 * 
 * Part of the DesignerPunk Button System infrastructure.
 * 
 * @module Button-VerticalListItem/platforms/android
 * @see Requirements: 1.1-1.5, 3.1-3.4, 11.5, 11.7
 */

package com.designerpunk.components.button

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import com.designerpunk.tokens.DesignTokens

// MARK: - Semantic Token Extensions

/**
 * Semantic token extensions for DesignTokens.
 * 
 * These extensions provide semantic color and border tokens for the
 * VerticalListButtonItem component. In production, these would be
 * generated by the Rosetta system.
 * 
 * Note: These are placeholder implementations using primitive tokens.
 * The actual values will be provided by the token generation system.
 */

// MARK: - Color Tokens (Semantic)

/** Background color - color.background
 * Requirements: 1.1, 1.5
 */
val DesignTokens.Companion.color_background: Int
    get() = 0xFFFFFFFF.toInt()

/** Default text color - color.text.default
 * Requirements: 1.1, 1.5
 */
val DesignTokens.Companion.color_text_default: Int
    get() = 0xFF1A1A1A.toInt()

/** Muted text color - color.text.muted
 * Requirements: 4.3
 */
val DesignTokens.Companion.color_text_muted: Int
    get() = 0xFF666666.toInt()

/** Selected state subtle background - color.select.selected.subtle
 * Requirements: 1.2, 1.4
 */
val DesignTokens.Companion.color_select_selected_background: Int
    get() = 0x1A6366F1.toInt() // 10% opacity of selected strong

/** Selected state strong foreground - color.select.selected.strong
 * Requirements: 1.2, 1.4, 2.3
 */
val DesignTokens.Companion.color_select_selected: Int
    get() = 0xFF6366F1.toInt() // Indigo/purple

/** Not selected state subtle background - color.select.notSelected.subtle
 * Requirements: 1.3
 */
val DesignTokens.Companion.color_select_not_selected_background: Int
    get() = 0xFFF5F5F5.toInt() // Light gray

/** Not selected state strong foreground - color.select.notSelected.strong
 * Requirements: 1.3
 */
val DesignTokens.Companion.color_select_not_selected: Int
    get() = 0xFF9CA3AF.toInt() // Gray

/** Error state subtle background - color.error.subtle
 * Requirements: 3.1
 */
val DesignTokens.Companion.color_error_subtle: Int
    get() = 0x1AEF4444.toInt() // 10% opacity of error strong

/** Error state strong foreground - color.error.strong
 * Requirements: 3.1, 3.2, 3.3, 2.4
 */
val DesignTokens.Companion.color_error_strong: Int
    get() = 0xFFEF4444.toInt() // Red

// MARK: - Border Tokens

/** Default border width (1dp) - borderDefault
 * Requirements: 1.1, 1.3, 1.4, 1.5
 */
val DesignTokens.Companion.border_border_default: Float
    get() = DesignTokens.border_width_100

/** Emphasis border width (2dp) - borderEmphasis
 * Requirements: 1.2, 3.1
 */
val DesignTokens.Companion.border_border_emphasis: Float
    get() = DesignTokens.border_width_200

// MARK: - Visual State Enum

/**
 * Visual state for the vertical list button item.
 * 
 * Determines the appearance of the button based on selection context:
 * - Tap Mode: Uses `REST` state only
 * - Select Mode: Uses `REST`, `SELECTED`, `NOT_SELECTED`
 * - Multi-Select Mode: Uses `CHECKED`, `UNCHECKED`
 * 
 * This enum matches the TypeScript definition:
 * ```typescript
 * type VisualState = 'rest' | 'selected' | 'notSelected' | 'checked' | 'unchecked';
 * ```
 * 
 * Requirements:
 * - 1.1: rest state styling
 * - 1.2: selected state styling
 * - 1.3: notSelected state styling
 * - 1.4: checked state styling
 * - 1.5: unchecked state styling
 */
enum class VisualState {
    /** Default state for Tap mode and initial Select mode */
    REST,
    
    /** Selected state in Select mode - shows checkmark, emphasis border */
    SELECTED,
    
    /** Not selected state in Select mode - muted appearance */
    NOT_SELECTED,
    
    /** Checked state in Multi-Select mode - shows checkmark */
    CHECKED,
    
    /** Unchecked state in Multi-Select mode */
    UNCHECKED;
    
    /** Whether this state shows the selection indicator (checkmark)
     * Requirements: 2.1, 2.2
     */
    val showsCheckmark: Boolean
        get() = when (this) {
            SELECTED, CHECKED -> true
            REST, NOT_SELECTED, UNCHECKED -> false
        }
    
    /** Whether this state uses emphasis border (2dp)
     * Only `SELECTED` state uses the emphasis border
     */
    val usesEmphasisBorder: Boolean
        get() = this == SELECTED
    
    /** Whether this state is part of Select mode
     * Select mode states: REST, SELECTED, NOT_SELECTED
     */
    val isSelectMode: Boolean
        get() = when (this) {
            REST, SELECTED, NOT_SELECTED -> true
            CHECKED, UNCHECKED -> false
        }
    
    /** Whether this state is part of Multi-Select mode
     * Multi-Select mode states: CHECKED, UNCHECKED
     */
    val isMultiSelectMode: Boolean
        get() = when (this) {
            CHECKED, UNCHECKED -> true
            REST, SELECTED, NOT_SELECTED -> false
        }
    
    /**
     * Accessibility state description for TalkBack.
     * 
     * Returns a human-readable description of the selection state that TalkBack
     * will announce to users. This enables users with visual impairments to
     * understand the current selection status of the button.
     * 
     * State descriptions:
     * - REST: Empty (no state to announce - default/neutral state)
     * - SELECTED: "Selected" (item is the current selection in single-select mode)
     * - NOT_SELECTED: "Not selected" (item is not selected in single-select mode)
     * - CHECKED: "Checked" (item is checked in multi-select mode)
     * - UNCHECKED: "Not checked" (item is not checked in multi-select mode)
     * 
     * Requirements: 10.3, 10.6, 10.8
     * - 10.3: Screen readers announce label and current state
     * - 10.6: TalkBack announces label and current selection state
     * - 10.8: Android uses Compose semantics for TalkBack support
     */
    val accessibilityStateDescription: String
        get() = when (this) {
            REST -> "" // No state to announce for rest/default state
            SELECTED -> "Selected"
            NOT_SELECTED -> "Not selected"
            CHECKED -> "Checked"
            UNCHECKED -> "Not checked"
        }
}

// MARK: - Checkmark Transition Enum

/**
 * Checkmark transition behavior when hiding.
 * 
 * Controls how the selection indicator (checkmark) animates when
 * transitioning from visible to hidden state.
 * 
 * Requirements:
 * - 7.3: fade transition - uses motion.selectionTransition
 * - 7.4: instant transition - hides immediately without animation
 */
enum class CheckmarkTransition {
    /** Fade out using motion.selectionTransition (250ms, standard easing) */
    FADE,
    
    /** Hide immediately without animation */
    INSTANT
}

// MARK: - Visual State Styles

/**
 * Visual styles for a specific state.
 * 
 * Contains all the styling properties needed to render the button
 * in a particular visual state. Uses DesignTokens for all color
 * and dimension values to ensure consistency with the design system.
 * 
 * Requirements:
 * - 1.1-1.5: State-specific styling
 * - 3.1-3.4: Error state overlay
 */
data class VisualStateStyles(
    val background: Color,
    val borderWidth: Dp,
    val borderColor: Color,
    val labelColor: Color,
    val iconColor: Color,
    val checkmarkVisible: Boolean
) {
    companion object {
        // MARK: - State-Specific Styles Using Design Tokens
        
        /** Rest state styles (Tap mode default)
         * Requirements: 1.1 - color.background, borderDefault (1dp), color.text.default
         */
        val rest = VisualStateStyles(
            background = Color(DesignTokens.color_background),
            borderWidth = DesignTokens.border_border_default.dp,
            borderColor = Color.Transparent,
            labelColor = Color(DesignTokens.color_text_default),
            iconColor = Color(DesignTokens.color_text_default),
            checkmarkVisible = false
        )
        
        /** Selected state styles (Select mode)
         * Requirements: 1.2 - color.select.selected.subtle, borderEmphasis (2dp), 
         *               color.select.selected.strong for border and label
         */
        val selected = VisualStateStyles(
            background = Color(DesignTokens.color_select_selected_background),
            borderWidth = DesignTokens.border_border_emphasis.dp,
            borderColor = Color(DesignTokens.color_select_selected),
            labelColor = Color(DesignTokens.color_select_selected),
            iconColor = Color(DesignTokens.color_select_selected),
            checkmarkVisible = true
        )
        
        /** Not selected state styles (Select mode)
         * Requirements: 1.3 - color.select.notSelected.subtle, borderDefault (1dp),
         *               transparent border, color.select.notSelected.strong
         */
        val notSelected = VisualStateStyles(
            background = Color(DesignTokens.color_select_not_selected_background),
            borderWidth = DesignTokens.border_border_default.dp,
            borderColor = Color.Transparent,
            labelColor = Color(DesignTokens.color_select_not_selected),
            iconColor = Color(DesignTokens.color_select_not_selected),
            checkmarkVisible = false
        )
        
        /** Checked state styles (Multi-Select mode)
         * Requirements: 1.4 - color.select.selected.subtle, borderDefault (1dp),
         *               transparent border, color.select.selected.strong
         */
        val checked = VisualStateStyles(
            background = Color(DesignTokens.color_select_selected_background),
            borderWidth = DesignTokens.border_border_default.dp,
            borderColor = Color.Transparent,
            labelColor = Color(DesignTokens.color_select_selected),
            iconColor = Color(DesignTokens.color_select_selected),
            checkmarkVisible = true
        )
        
        /** Unchecked state styles (Multi-Select mode)
         * Requirements: 1.5 - color.background, borderDefault (1dp),
         *               transparent border, color.text.default
         */
        val unchecked = VisualStateStyles(
            background = Color(DesignTokens.color_background),
            borderWidth = DesignTokens.border_border_default.dp,
            borderColor = Color.Transparent,
            labelColor = Color(DesignTokens.color_text_default),
            iconColor = Color(DesignTokens.color_text_default),
            checkmarkVisible = false
        )
        
        // MARK: - Error State Styles
        
        /** Error state styles for Select mode (full treatment)
         * Requirements: 3.1 - color.error.subtle background, borderEmphasis (2dp),
         *               color.error.strong for border, label, and icon
         */
        fun errorSelectMode(checkmarkVisible: Boolean): VisualStateStyles {
            return VisualStateStyles(
                background = Color(DesignTokens.color_error_subtle),
                borderWidth = DesignTokens.border_border_emphasis.dp,
                borderColor = Color(DesignTokens.color_error_strong),
                labelColor = Color(DesignTokens.color_error_strong),
                iconColor = Color(DesignTokens.color_error_strong),
                checkmarkVisible = checkmarkVisible
            )
        }
        
        /** Error state styles for Multi-Select mode (colors only)
         * Requirements: 3.2 - preserves background and border, only changes label/icon colors
         */
        fun errorMultiSelectMode(baseStyles: VisualStateStyles): VisualStateStyles {
            return baseStyles.copy(
                labelColor = Color(DesignTokens.color_error_strong),
                iconColor = Color(DesignTokens.color_error_strong)
            )
        }
    }
}

// MARK: - Visual State Mapping

/**
 * Maps visual states to their corresponding styles.
 * 
 * This map provides O(1) lookup for visual state styles,
 * matching the TypeScript `visualStateMap` implementation.
 * 
 * Requirements:
 * - 1.1-1.5: Visual state rendering
 */
val visualStateMap: Map<VisualState, VisualStateStyles> = mapOf(
    VisualState.REST to VisualStateStyles.rest,
    VisualState.SELECTED to VisualStateStyles.selected,
    VisualState.NOT_SELECTED to VisualStateStyles.notSelected,
    VisualState.CHECKED to VisualStateStyles.checked,
    VisualState.UNCHECKED to VisualStateStyles.unchecked
)

// MARK: - Style Retrieval

/**
 * Gets the visual state styles for a given state.
 * 
 * Provides a safe way to retrieve styles with a fallback to rest state
 * if the state is not found in the map (should never happen with enum).
 * 
 * @param visualState The visual state to get styles for
 * @return The corresponding VisualStateStyles
 */
fun getVisualStateStyles(visualState: VisualState): VisualStateStyles {
    return visualStateMap[visualState] ?: VisualStateStyles.rest
}

// MARK: - Error Styling

/**
 * Applies error styling on top of base visual state styles.
 * 
 * Error treatment is mode-specific:
 * - Select mode: Full error treatment (border + background + colors)
 *   - Background: color.error.subtle
 *   - Border: borderEmphasis (2dp), color.error.strong
 *   - Label/Icon: color.error.strong
 * - Multi-Select mode: Text/icon colors only (no border/background change)
 *   - Background: preserved from base state
 *   - Border: preserved from base state
 *   - Label/Icon: color.error.strong
 * - Tap mode (rest state only): No effect (nothing to validate)
 * 
 * Requirements:
 * - 3.1: Select mode error treatment (full treatment)
 * - 3.2: Multi-Select mode error treatment (colors only)
 * - 3.3: Error colors (color.error.strong for foreground)
 * - 3.4: Tap mode ignores error prop
 * 
 * @param baseStyles The base visual state styles
 * @param visualState The current visual state
 * @return Modified styles with error treatment applied
 */
fun applyErrorStyles(
    baseStyles: VisualStateStyles,
    visualState: VisualState
): VisualStateStyles {
    
    if (visualState.isSelectMode) {
        // Select mode: full error treatment (border + background + colors)
        // Requirements: 3.1
        return VisualStateStyles.errorSelectMode(checkmarkVisible = baseStyles.checkmarkVisible)
    }
    
    if (visualState.isMultiSelectMode) {
        // Multi-Select mode: text/icon colors only
        // Requirements: 3.2
        return VisualStateStyles.errorMultiSelectMode(baseStyles = baseStyles)
    }
    
    // Tap mode (rest state in tap context): error has no effect
    // Requirements: 3.4
    return baseStyles
}

/**
 * Computes the final styles for a visual state, optionally applying error treatment.
 * 
 * This is the primary entry point for getting styles in the component.
 * It handles both normal state styling and error state overlay.
 * 
 * @param visualState The current visual state
 * @param error Whether error styling should be applied
 * @return The computed VisualStateStyles
 */
fun computeStyles(
    visualState: VisualState,
    error: Boolean
): VisualStateStyles {
    val baseStyles = getVisualStateStyles(visualState)
    
    return if (error) {
        applyErrorStyles(baseStyles, visualState)
    } else {
        baseStyles
    }
}

// MARK: - Padding Compensation

/**
 * Calculates the block padding based on border width for height stability.
 * 
 * Padding compensation ensures constant 48dp height across all visual states:
 * - 1dp border: 11dp padding (1 + 11 + 24 + 11 + 1 = 48)
 * - 2dp border: 10dp padding (2 + 10 + 24 + 10 + 2 = 48)
 * 
 * This matches the web implementation's padding compensation approach
 * and the component token definitions:
 * - verticalListItem.paddingBlock.rest = 11 (SPACING_BASE_VALUE * 1.375)
 * - verticalListItem.paddingBlock.selected = 10 (references space125)
 * 
 * Requirements:
 * - 6.1: 11dp padding for 1dp border (borderDefault)
 * - 6.2: 10dp padding for 2dp border (borderEmphasis)
 * - 6.3: Constant 48dp total height
 * 
 * @param borderWidth The current border width
 * @return The appropriate block padding value
 */
fun calculatePaddingBlock(borderWidth: Dp): Dp {
    // borderEmphasis (2dp) requires 10dp padding
    // borderDefault (1dp) requires 11dp padding
    // Uses component tokens for consistency with design system
    return if (borderWidth >= DesignTokens.border_border_emphasis.dp) {
        VERTICAL_LIST_ITEM_PADDING_BLOCK_SELECTED
    } else {
        VERTICAL_LIST_ITEM_PADDING_BLOCK_REST
    }
}

/**
 * Calculates the block padding for a given visual state.
 * 
 * Convenience function that determines padding based on the visual state's
 * border width requirement.
 * 
 * @param visualState The current visual state
 * @return The appropriate block padding value
 */
fun calculatePaddingBlock(visualState: VisualState): Dp {
    val styles = getVisualStateStyles(visualState)
    return calculatePaddingBlock(styles.borderWidth)
}

/**
 * Calculates the block padding for a given visual state with error consideration.
 * 
 * When error is true in Select mode, the border width changes to emphasis (2dp),
 * which affects the padding calculation.
 * 
 * @param visualState The current visual state
 * @param error Whether error styling is applied
 * @return The appropriate block padding value
 */
fun calculatePaddingBlock(visualState: VisualState, error: Boolean): Dp {
    val styles = computeStyles(visualState, error)
    return calculatePaddingBlock(styles.borderWidth)
}

// MARK: - Component Tokens (Padding Compensation)

/**
 * Height Stability Through Padding Compensation
 * 
 * The component maintains a constant 48dp height across all visual states by
 * adjusting padding when border width changes. This prevents layout shifts
 * when transitioning between states.
 * 
 * Height Formula: (Border × 2) + (Padding × 2) + Content = 48dp
 * 
 * Rest State (1dp border):
 *   48dp = (1dp × 2) + (11dp × 2) + 24dp
 *   48dp = 2dp + 22dp + 24dp ✓
 * 
 * Selected State (2dp border):
 *   48dp = (2dp × 2) + (10dp × 2) + 24dp
 *   48dp = 4dp + 20dp + 24dp ✓
 * 
 * This approach matches the web implementation's padding compensation and
 * ensures cross-platform consistency.
 * 
 * Requirements:
 * - 6.1: 11dp padding for 1dp border (borderDefault)
 * - 6.2: 10dp padding for 2dp border (borderEmphasis)
 * - 6.3: Constant 48dp total height
 * - 14.6: Minimum 48dp touch target per Material Design guidelines
 */

/**
 * Block padding for rest state (11dp) - used with 1dp border
 * Requirements: 6.1 - 11dp padding for 1dp border
 * Formula: SPACING_BASE_VALUE * 1.375 = 8 * 1.375 = 11
 * Height calculation: 1dp border + 11dp padding + 24dp content + 11dp padding + 1dp border = 48dp
 */
val VERTICAL_LIST_ITEM_PADDING_BLOCK_REST: Dp = 11.dp

/**
 * Block padding for selected state (10dp) - used with 2dp border
 * Requirements: 6.2 - 10dp padding for 2dp border
 * References: space125 primitive token
 * Height calculation: 2dp border + 10dp padding + 24dp content + 10dp padding + 2dp border = 48dp
 */
val VERTICAL_LIST_ITEM_PADDING_BLOCK_SELECTED: Dp = 10.dp

/**
 * Minimum touch target size (48dp) per Material Design guidelines
 * Requirements: 5.1, 14.6 - Minimum height for touch targets
 * 
 * This value is also available via DesignTokens.tap_area_recommended
 * but is defined here for clarity in the padding compensation context.
 */
val VERTICAL_LIST_ITEM_MIN_HEIGHT: Dp = 48.dp

/**
 * Content height (24dp) - the height of the label/icon content area
 * This is the space between the top and bottom padding.
 */
val VERTICAL_LIST_ITEM_CONTENT_HEIGHT: Dp = 24.dp

// MARK: - Height Validation

/**
 * Validates that the padding compensation produces the correct total height.
 * 
 * This function can be used in tests to verify the height stability invariant.
 * 
 * @param borderWidth The border width being used
 * @param paddingBlock The block padding being used
 * @param contentHeight The content height (default 24dp)
 * @return The calculated total height
 */
fun calculateTotalHeight(
    borderWidth: Dp,
    paddingBlock: Dp,
    contentHeight: Dp = VERTICAL_LIST_ITEM_CONTENT_HEIGHT
): Dp {
    // Total = (border × 2) + (padding × 2) + content
    return (borderWidth * 2) + (paddingBlock * 2) + contentHeight
}

/**
 * Validates that the padding compensation is correct for a given border width.
 * 
 * @param borderWidth The border width to validate
 * @return True if the padding compensation produces 48dp total height
 */
fun validatePaddingCompensation(borderWidth: Dp): Boolean {
    val paddingBlock = calculatePaddingBlock(borderWidth)
    val totalHeight = calculateTotalHeight(borderWidth, paddingBlock)
    return totalHeight == VERTICAL_LIST_ITEM_MIN_HEIGHT
}

/**
 * Validates that the padding compensation is correct for a given visual state.
 * 
 * @param visualState The visual state to validate
 * @param error Whether error styling is applied
 * @return True if the padding compensation produces 48dp total height
 */
fun validatePaddingCompensation(visualState: VisualState, error: Boolean = false): Boolean {
    val styles = computeStyles(visualState, error)
    return validatePaddingCompensation(styles.borderWidth)
}
