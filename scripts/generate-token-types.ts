#!/usr/bin/env ts-node
/**
 * Token Type Generation Script
 * 
 * Generates TypeScript union types from semantic token definitions.
 * This enables type-safe token references in Container component props.
 * 
 * Generated types:
 * - ColorTokenName: Union of all color token names
 * - ShadowTokenName: Union of all shadow token names
 * - OpacityTokenName: Union of all opacity token names
 * 
 * Usage:
 *   npm run generate:types
 *   ts-node scripts/generate-token-types.ts
 */

import * as fs from 'fs';
import * as path from 'path';

/**
 * Token file configuration
 * Maps semantic token files to their generated type names
 */
interface TokenFileConfig {
  /** Path to semantic token file relative to project root */
  path: string;
  /** Name of the exported token object in the file */
  exportName: string;
  /** Name of the generated TypeScript type */
  typeName: string;
  /** Description for the generated type */
  description: string;
}

/**
 * Token files to process
 */
const TOKEN_FILES: TokenFileConfig[] = [
  {
    path: 'src/tokens/semantic/ColorTokens.ts',
    exportName: 'colorTokens',
    typeName: 'ColorTokenName',
    description: 'Union type of all semantic color token names'
  },
  {
    path: 'src/tokens/semantic/ShadowTokens.ts',
    exportName: 'shadowTokens',
    typeName: 'ShadowTokenName',
    description: 'Union type of all semantic shadow token names'
  },
  {
    path: 'src/tokens/semantic/OpacityTokens.ts',
    exportName: 'opacityTokens',
    typeName: 'OpacityTokenName',
    description: 'Union type of all semantic opacity token names'
  }
];

/**
 * Output file path for generated types
 */
const OUTPUT_PATH = 'src/types/generated/TokenTypes.ts';

/**
 * Extract token names from a token file
 * Reads the file and extracts object keys from the exported token object
 */
function extractTokenNames(filePath: string, exportName: string): string[] {
  try {
    // Read the token file
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    
    // Extract token names using regex
    // Matches: 'token.name': { or "token.name": {
    const tokenNameRegex = /['"]([^'"]+)['"]\s*:\s*\{/g;
    const matches = [...fileContent.matchAll(tokenNameRegex)];
    
    // Extract token names from matches
    const tokenNames = matches
      .map(match => match[1])
      .filter(name => name && name.length > 0);
    
    // Remove duplicates and sort
    const uniqueNames = [...new Set(tokenNames)].sort();
    
    if (uniqueNames.length === 0) {
      console.warn(`‚ö†Ô∏è  No token names found in ${filePath}`);
    }
    
    return uniqueNames;
  } catch (error) {
    console.error(`‚ùå Error reading ${filePath}:`, error);
    return [];
  }
}

/**
 * Generate TypeScript union type from token names
 */
function generateUnionType(
  typeName: string,
  tokenNames: string[],
  description: string
): string {
  if (tokenNames.length === 0) {
    return `/**
 * ${description}
 * 
 * WARNING: No tokens found during generation
 */
export type ${typeName} = never;
`;
  }
  
  // Format token names as union type with proper indentation
  const unionMembers = tokenNames
    .map(name => `  | '${name}'`)
    .join('\n');
  
  return `/**
 * ${description}
 * 
 * Generated from semantic token definitions.
 * Total tokens: ${tokenNames.length}
 */
export type ${typeName} =
${unionMembers};
`;
}

/**
 * Generate complete TypeScript file content
 */
function generateTypeFile(): string {
  const timestamp = new Date().toISOString();
  
  let content = `/**
 * AUTO-GENERATED TOKEN TYPES
 * 
 * This file is automatically generated from semantic token definitions.
 * DO NOT EDIT MANUALLY - changes will be overwritten.
 * 
 * To regenerate: npm run generate:types
 * 
 * Generated: ${timestamp}
 */

`;
  
  // Process each token file
  for (const config of TOKEN_FILES) {
    console.log(`üìñ Reading ${config.path}...`);
    
    const tokenNames = extractTokenNames(config.path, config.exportName);
    console.log(`   Found ${tokenNames.length} tokens`);
    
    const typeDefinition = generateUnionType(
      config.typeName,
      tokenNames,
      config.description
    );
    
    content += typeDefinition + '\n';
  }
  
  // Add helper type for all token names
  content += `/**
 * Union of all semantic token names across all categories
 */
export type SemanticTokenName = ColorTokenName | ShadowTokenName | OpacityTokenName;

/**
 * Type guard to check if a string is a valid color token name
 */
export function isColorTokenName(name: string): name is ColorTokenName {
  // This will be validated at runtime by the token system
  return name.startsWith('color.') || name.startsWith('glow.');
}

/**
 * Type guard to check if a string is a valid shadow token name
 */
export function isShadowTokenName(name: string): name is ShadowTokenName {
  return name.startsWith('shadow.');
}

/**
 * Type guard to check if a string is a valid opacity token name
 */
export function isOpacityTokenName(name: string): name is OpacityTokenName {
  return name.startsWith('opacity.');
}
`;
  
  return content;
}

/**
 * Write generated types to output file
 */
function writeTypeFile(content: string): void {
  try {
    // Ensure output directory exists
    const outputDir = path.dirname(OUTPUT_PATH);
    if (!fs.existsSync(outputDir)) {
      console.log(`üìÅ Creating directory: ${outputDir}`);
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Write the file
    fs.writeFileSync(OUTPUT_PATH, content, 'utf-8');
    console.log(`‚úÖ Generated types written to ${OUTPUT_PATH}`);
  } catch (error) {
    console.error(`‚ùå Error writing ${OUTPUT_PATH}:`, error);
    process.exit(1);
  }
}

/**
 * Main execution
 */
function main(): void {
  console.log('üöÄ Starting token type generation...\n');
  
  // Validate token files exist
  for (const config of TOKEN_FILES) {
    if (!fs.existsSync(config.path)) {
      console.error(`‚ùå Token file not found: ${config.path}`);
      process.exit(1);
    }
  }
  
  // Generate type file content
  const content = generateTypeFile();
  
  // Write to output file
  writeTypeFile(content);
  
  console.log('\n‚ú® Token type generation complete!');
}

// Run the script
main();
