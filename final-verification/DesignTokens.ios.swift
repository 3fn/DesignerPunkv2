///
/// DesignerPunk Design System - iOS Tokens
/// Generated: 2026-01-14T14:43:03.019Z
/// Version: 1.0.0
/// Platform: iOS (Swift Constants)
///

import UIKit

public struct DesignTokens {

    // ============================================
    // PRIMITIVE TOKENS
    /// Mathematical foundation
    // ============================================


    // MARK: - BLEND TOKENS
    /// base × 1 = 0.04 × 1 = 0.04
    public static let blend100: CGFloat = 0.04
    /// base × 2 = 0.04 × 2 = 0.08
    public static let blend200: CGFloat = 0.08
    /// base × 3 = 0.04 × 3 = 0.12
    public static let blend300: CGFloat = 0.12
    /// base × 4 = 0.04 × 4 = 0.16
    public static let blend400: CGFloat = 0.16
    /// base × 5 = 0.04 × 5 = 0.20
    public static let blend500: CGFloat = 0.2

    // MARK: - BORDERWIDTH TOKENS
    /// base × 0 = 1 × 0 = 0
    public static let borderWidth000: CGFloat = 0
    /// base × 1 = 1 × 1 = 1
    public static let borderWidth100: CGFloat = 1
    /// base × 2 = 1 × 2 = 2
    public static let borderWidth200: CGFloat = 2
    /// base × 4 = 1 × 4 = 4
    public static let borderWidth400: CGFloat = 4

    // MARK: - BREAKPOINT TOKENS
    /// Practical device-based value
    public static let breakpointXs: CGFloat = 320
    /// Practical device-based value
    public static let breakpointSm: CGFloat = 375
    /// Practical device-based value
    public static let breakpointMd: CGFloat = 1024
    /// Practical device-based value
    public static let breakpointLg: CGFloat = 1440

    // MARK: - COLOR TOKENS
    /// Systematic gray scale progression - lightest
    public static let gray100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic gray scale progression - medium-light
    public static let gray200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic gray scale progression - medium
    public static let gray300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic gray scale progression - dark
    public static let gray400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic gray scale progression - darkest
    public static let gray500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic black scale progression - lightest
    public static let black100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic black scale progression - medium
    public static let black200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic black scale progression - dark
    public static let black300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic black scale progression - very dark
    public static let black400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic black scale progression - pure black
    public static let black500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic white scale progression - pure white
    public static let white100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic white scale progression - near white
    public static let white200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic white scale progression - light gray-white
    public static let white300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic white scale progression - medium gray-white
    public static let white400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic white scale progression - dark gray-white
    public static let white500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic yellow scale progression - lightest
    public static let yellow100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic yellow scale progression - medium-light
    public static let yellow200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic yellow scale progression - bright
    public static let yellow300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic yellow scale progression - dark
    public static let yellow400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic yellow scale progression - darkest
    public static let yellow500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic orange scale progression - lightest
    public static let orange100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic orange scale progression - medium-light
    public static let orange200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic orange scale progression - bright
    public static let orange300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic orange scale progression - dark
    public static let orange400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic orange scale progression - darkest
    public static let orange500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic purple scale progression - lightest
    public static let purple100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic purple scale progression - medium-light
    public static let purple200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic purple scale progression - primary brand
    public static let purple300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic purple scale progression - dark
    public static let purple400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic purple scale progression - darkest
    public static let purple500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic pink scale progression - lightest
    public static let pink100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic pink scale progression - medium-light
    public static let pink200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic pink scale progression - base
    public static let pink300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic pink scale progression - dark
    public static let pink400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic pink scale progression - darkest
    public static let pink500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic green scale progression - lightest
    public static let green100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic green scale progression - medium-light
    public static let green200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic green scale progression - bright
    public static let green300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic green scale progression - strong
    public static let green400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic green scale progression - darkest/glow
    public static let green500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic cyan scale progression - lightest
    public static let cyan100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic cyan scale progression - medium-light
    public static let cyan200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic cyan scale progression - tech primary
    public static let cyan300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic cyan scale progression - dark
    public static let cyan400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic cyan scale progression - darkest
    public static let cyan500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic teal scale progression - lightest
    public static let teal100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic teal scale progression - medium-light
    public static let teal200: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic teal scale progression - secondary UI
    public static let teal300: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic teal scale progression - dark
    public static let teal400: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic teal scale progression - darkest
    public static let teal500: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic shadow color family - pure black (0, 0, 0) - mode-agnostic
    public static let shadowBlack100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic shadow color family - blue-tinted gray for sunrise/sunset lighting - mode-agnostic
    public static let shadowBlue100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic shadow color family - warm-tinted gray for cool lighting environments - mode-agnostic
    public static let shadowOrange100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }
    /// Systematic shadow color family - blue-gray for ambient/overcast conditions - mode-agnostic
    public static let shadowGray100: UIColor = UIColor { traitCollection in /* dynamic color implementation */ }

    // MARK: - DENSITY TOKENS
    /// base × 0.75 = 1.0 × 0.75 = 0.75
    public static let densityCompact: CGFloat = 0.75
    /// base × 1 = 1.0 × 1 = 1.0
    public static let densityDefault: CGFloat = 1
    /// base × 1.25 = 1.0 × 1.25 = 1.25
    public static let densityComfortable: CGFloat = 1.25
    /// base × 1.5 = 1.0 × 1.5 = 1.5
    public static let densitySpacious: CGFloat = 1.5

    // MARK: - FONTFAMILY TOKENS
    /// N/A - Categorical value
    public static let fontFamilySystem: String = "-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif"
    /// N/A - Categorical value
    public static let fontFamilyMono: String = "SF Mono, Monaco, Inconsolata, "Roboto Mono", Consolas, "Courier New", monospace"
    /// N/A - Categorical value
    public static let fontFamilyDisplay: String = "Rajdhani, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif"
    /// N/A - Categorical value
    public static let fontFamilyBody: String = "Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif"

    // MARK: - FONTSIZE TOKENS
    /// base ÷ (1.125²) = 16 ÷ 1.266 ≈ 13
    public static let fontSize050: CGFloat = 13
    /// base ÷ 1.125 = 16 ÷ 1.125 ≈ 14
    public static let fontSize075: CGFloat = 14
    /// base × 1 = 16 × 1 = 16
    public static let fontSize100: CGFloat = 16
    /// base × 1.125 = 16 × 1.125 = 18
    public static let fontSize125: CGFloat = 18
    /// base × (1.125²) = 16 × 1.266 ≈ 20
    public static let fontSize150: CGFloat = 20
    /// base × (1.125³) = 16 × 1.424 ≈ 23
    public static let fontSize200: CGFloat = 23
    /// base × (1.125⁴) = 16 × 1.602 ≈ 26
    public static let fontSize300: CGFloat = 26
    /// base × (1.125⁵) = 16 × 1.802 ≈ 29
    public static let fontSize400: CGFloat = 29
    /// base × (1.125⁶) = 16 × 2.027 ≈ 32.4 → 33 (adjusted for 4pt subgrid)
    public static let fontSize500: CGFloat = 33
    /// base × (1.125⁷) = 16 × 2.281 ≈ 36.5 → 37 (adjusted for 4pt subgrid)
    public static let fontSize600: CGFloat = 37
    /// base × (1.125⁸) = 16 × 2.566 ≈ 41.1 → 42 (adjusted for 4pt subgrid)
    public static let fontSize700: CGFloat = 42

    // MARK: - FONTWEIGHT TOKENS
    /// base × 0.25 = 400 × 0.25 = 100
    public static let fontWeight100: UIFont.Weight = 100
    /// base × 0.5 = 400 × 0.5 = 200
    public static let fontWeight200: UIFont.Weight = 200
    /// base × 0.75 = 400 × 0.75 = 300
    public static let fontWeight300: UIFont.Weight = 300
    /// base × 1 = 400 × 1 = 400
    public static let fontWeight400: UIFont.Weight = 400
    /// base × 1.25 = 400 × 1.25 = 500
    public static let fontWeight500: UIFont.Weight = 500
    /// base × 1.5 = 400 × 1.5 = 600
    public static let fontWeight600: UIFont.Weight = 600
    /// base × 1.75 = 400 × 1.75 = 700
    public static let fontWeight700: UIFont.Weight = 700
    /// base × 2 = 400 × 2 = 800
    public static let fontWeight800: UIFont.Weight = 800
    /// base × 2.25 = 400 × 2.25 = 900
    public static let fontWeight900: UIFont.Weight = 900

    // MARK: - GLOW TOKENS
    /// base × 1 = 8 × 1 = 8
    public static let glowBlur100: CGFloat = 8
    /// base × 2 = 8 × 2 = 16
    public static let glowBlur200: CGFloat = 16
    /// base × 3 = 8 × 3 = 24
    public static let glowBlur300: CGFloat = 24
    /// base × 4 = 8 × 4 = 32
    public static let glowBlur400: CGFloat = 32
    /// base × 5 = 8 × 5 = 40
    public static let glowBlur500: CGFloat = 40
    /// base × 1 = 0.8 × 1 = 0.8
    public static let glowOpacity100: CGFloat = 0.8
    /// base × 0.75 = 0.8 × 0.75 = 0.6
    public static let glowOpacity200: CGFloat = 0.6
    /// base × 0.5 = 0.8 × 0.5 = 0.4
    public static let glowOpacity300: CGFloat = 0.4
    /// base × 0.25 = 0.8 × 0.25 = 0.2
    public static let glowOpacity400: CGFloat = 0.2

    // MARK: - LETTERSPACING TOKENS
    /// base - 0.025 = 0 - 0.025 = -0.025
    public static let letterSpacing025: CGFloat = -0.025
    /// base - 0.05 = 0 - 0.05 = -0.05
    public static let letterSpacing050: CGFloat = -0.05
    /// base × 1 = 0 × 1 = 0
    public static let letterSpacing100: CGFloat = 0
    /// base + 0.025 = 0 + 0.025 = 0.025
    public static let letterSpacing125: CGFloat = 0.025
    /// base + 0.05 = 0 + 0.05 = 0.05
    public static let letterSpacing150: CGFloat = 0.05

    // MARK: - LINEHEIGHT TOKENS
    /// fontSize050 × baseValue ≈ 20
    public static let lineHeight050: CGFloat = 1.538
    /// fontSize075 × baseValue ≈ 20
    public static let lineHeight075: CGFloat = 1.429
    /// fontSize100 × baseValue = 24
    public static let lineHeight100: CGFloat = 1.5
    /// fontSize125 × baseValue ≈ 28
    public static let lineHeight125: CGFloat = 1.556
    /// fontSize150 × baseValue = 28
    public static let lineHeight150: CGFloat = 1.4
    /// fontSize200 × baseValue ≈ 32
    public static let lineHeight200: CGFloat = 1.391
    /// fontSize300 × baseValue ≈ 32
    public static let lineHeight300: CGFloat = 1.231
    /// fontSize400 × baseValue ≈ 36
    public static let lineHeight400: CGFloat = 1.241
    /// fontSize500 × baseValue ≈ 40
    public static let lineHeight500: CGFloat = 1.212
    /// fontSize600 × baseValue ≈ 44
    public static let lineHeight600: CGFloat = 1.19
    /// fontSize700 × baseValue ≈ 48
    public static let lineHeight700: CGFloat = 1.143

    // MARK: - OPACITY TOKENS
    /// base × 0 = 0.08 × 0 = 0.0
    public static let opacity000: CGFloat = 0
    /// base × 1 = 0.08 × 1 = 0.08
    public static let opacity100: CGFloat = 0.08
    /// base × 2 = 0.08 × 2 = 0.16
    public static let opacity200: CGFloat = 0.16
    /// base × 3 = 0.08 × 3 = 0.24
    public static let opacity300: CGFloat = 0.24
    /// base × 4 = 0.08 × 4 = 0.32
    public static let opacity400: CGFloat = 0.32
    /// base × 5 = 0.08 × 5 = 0.40
    public static let opacity500: CGFloat = 0.4
    /// base × 6 = 0.08 × 6 = 0.48
    public static let opacity600: CGFloat = 0.48
    /// base × 7 = 0.08 × 7 = 0.56
    public static let opacity700: CGFloat = 0.56
    /// base × 8 = 0.08 × 8 = 0.64
    public static let opacity800: CGFloat = 0.64
    /// base × 9 = 0.08 × 9 = 0.72
    public static let opacity900: CGFloat = 0.72
    /// base × 10 = 0.08 × 10 = 0.80
    public static let opacity1000: CGFloat = 0.8
    /// base × 11 = 0.08 × 11 = 0.88
    public static let opacity1100: CGFloat = 0.88
    /// base × 12 = 0.08 × 12 = 0.96
    public static let opacity1200: CGFloat = 0.96
    /// Special case: full opacity = 1.0
    public static let opacity1300: CGFloat = 1

    // MARK: - RADIUS TOKENS
    /// base × 0 = 8 × 0 = 0
    public static let radius000: CGFloat = 0
    /// base × 0.25 = 8 × 0.25 = 2
    public static let radius025: CGFloat = 2
    /// base × 0.5 = 8 × 0.5 = 4
    public static let radius050: CGFloat = 4
    /// base × 0.75 = 8 × 0.75 = 6
    public static let radius075: CGFloat = 6
    /// base × 1 = 8 × 1 = 8
    public static let radius100: CGFloat = 8
    /// base × 1.25 = 8 × 1.25 = 10
    public static let radius125: CGFloat = 10
    /// base × 1.5 = 8 × 1.5 = 12
    public static let radius150: CGFloat = 12
    /// base × 2 = 8 × 2 = 16
    public static let radius200: CGFloat = 16
    /// base × 2.5 = 8 × 2.5 = 20
    public static let radius250: CGFloat = 20
    /// base × 3 = 8 × 3 = 24
    public static let radius300: CGFloat = 24
    /// base × 4 = 8 × 4 = 32
    public static let radius400: CGFloat = 32
    /// special case = 9999 (effectively infinite)
    public static let radiusFull: CGFloat = 9999
    /// percentage = 50% (creates circle from square)
    public static let radiusHalf: CGFloat = "Circle"

    // MARK: - SHADOW TOKENS
    /// base × 1 = 4 × 1 = 4
    public static let shadowOffsetX100: CGFloat = 4
    /// base × 1.5 = 4 × 1.5 = 6
    public static let shadowOffsetX150: CGFloat = 6
    /// base × 2 = 4 × 2 = 8
    public static let shadowOffsetX200: CGFloat = 8
    /// base × 3 = 4 × 3 = 12
    public static let shadowOffsetX300: CGFloat = 12
    /// base × -3 = 4 × -3 = -12
    public static let shadowOffsetXN300: CGFloat = -12
    /// base × -2 = 4 × -2 = -8
    public static let shadowOffsetXN200: CGFloat = -8
    /// base × -1.5 = 4 × -1.5 = -6
    public static let shadowOffsetXN150: CGFloat = -6
    /// base × -1 = 4 × -1 = -4
    public static let shadowOffsetXN100: CGFloat = -4
    /// base × 0 = 4 × 0 = 0
    public static let shadowOffsetX000: CGFloat = 0
    /// base × 1 = 4 × 1 = 4
    public static let shadowOffsetY100: CGFloat = 4
    /// base × 2 = 4 × 2 = 8
    public static let shadowOffsetY200: CGFloat = 8
    /// base × 3 = 4 × 3 = 12
    public static let shadowOffsetY300: CGFloat = 12
    /// base × 4 = 4 × 4 = 16
    public static let shadowOffsetY400: CGFloat = 16
    /// base × 0 = 4 × 0 = 0
    public static let shadowOffsetY000: CGFloat = 0
    /// base × 0 = 4 × 0 = 0
    public static let shadowBlurNone: CGFloat = 0
    /// base × 1 = 4 × 1 = 4
    public static let shadowBlurHard: CGFloat = 4
    /// base × 3 = 4 × 3 = 12
    public static let shadowBlurModerate: CGFloat = 12
    /// base × 5 = 4 × 5 = 20
    public static let shadowBlurSoft: CGFloat = 20
    /// base × 4 = 4 × 4 = 16
    public static let shadowBlurDepth200: CGFloat = 16
    /// base × 6 = 4 × 6 = 24
    public static let shadowBlurDepth300: CGFloat = 24
    /// base × 0 = 0.3 × 0 = 0
    public static let shadowOpacityNone: CGFloat = 0
    /// base × 1.33 = 0.3 × 1.33 ≈ 0.4
    public static let shadowOpacityHard: CGFloat = 0.4
    /// base × 1 = 0.3 × 1 = 0.3
    public static let shadowOpacityModerate: CGFloat = 0.3
    /// base × 0.67 = 0.3 × 0.67 ≈ 0.2
    public static let shadowOpacitySoft: CGFloat = 0.2
    /// base × 1.17 = 0.3 × 1.17 ≈ 0.35
    public static let shadowOpacityDepth200: CGFloat = 0.35
    /// base × 1.33 = 0.3 × 1.33 ≈ 0.4
    public static let shadowOpacityDepth300: CGFloat = 0.4

    // MARK: - SPACING TOKENS
    /// base × 0 = 8 × 0 = 0
    public static let space000: CGFloat = 0
    /// base × 0.25 = 8 × 0.25 = 2
    public static let space025: CGFloat = 2
    /// base × 0.5 = 8 × 0.5 = 4
    public static let space050: CGFloat = 4
    /// space100 × 0.75
    public static let space075: CGFloat = 6
    /// base × 1 = 8 × 1 = 8
    public static let space100: CGFloat = 8
    /// space100 × 1.25
    public static let space125: CGFloat = 10
    /// base × 1.5 = 8 × 1.5 = 12
    public static let space150: CGFloat = 12
    /// base × 2 = 8 × 2 = 16
    public static let space200: CGFloat = 16
    /// space100 × 2.5
    public static let space250: CGFloat = 20
    /// base × 3 = 8 × 3 = 24
    public static let space300: CGFloat = 24
    /// base × 4 = 8 × 4 = 32
    public static let space400: CGFloat = 32
    /// base × 5 = 8 × 5 = 40
    public static let space500: CGFloat = 40
    /// base × 6 = 8 × 6 = 48
    public static let space600: CGFloat = 48
    /// base - 100 = 250 - 100 = 150
    public static let duration150: CGFloat = 0.15
    /// base × 1 = 250 × 1 = 250
    public static let duration250: CGFloat = 0.25
    /// base + 100 = 250 + 100 = 350
    public static let duration350: CGFloat = 0.35
    /// Material Design standard curve: cubic-bezier(0.4, 0.0, 0.2, 1)
    public static let easingStandard: CGFloat = "cubic-bezier(0.4, 0.0, 0.2, 1)"
    /// Material Design deceleration curve: cubic-bezier(0.0, 0.0, 0.2, 1)
    public static let easingDecelerate: CGFloat = "cubic-bezier(0.0, 0.0, 0.2, 1)"
    /// Material Design acceleration curve: cubic-bezier(0.4, 0.0, 1, 1)
    public static let easingAccelerate: CGFloat = "cubic-bezier(0.4, 0.0, 1, 1)"
    /// base - 0.12 = 1.00 - 0.12 = 0.88 (8-interval progression: 3 × 0.04)
    public static let scale088: CGFloat = 0.88
    /// base - 0.08 = 1.00 - 0.08 = 0.92 (8-interval progression: 2 × 0.04)
    public static let scale092: CGFloat = 0.92
    /// base - 0.04 = 1.00 - 0.04 = 0.96 (8-interval progression: 1 × 0.04)
    public static let scale096: CGFloat = 0.96
    /// base × 1 = 1.00 × 1 = 1.00 (baseline, no transformation)
    public static let scale100: CGFloat = 1
    /// base + 0.04 = 1.00 + 0.04 = 1.04 (8-interval progression: 1 × 0.04)
    public static let scale104: CGFloat = 1.04
    /// base + 0.08 = 1.00 + 0.08 = 1.08 (8-interval progression: 2 × 0.04)
    public static let scale108: CGFloat = 1.08

    // MARK: - TAPAREA TOKENS
    /// base × 1 = 44 × 1 = 44
    public static let tapAreaMinimum: CGFloat = 44
    /// base × 1.09 = 44 × 1.09 ≈ 48
    public static let tapAreaRecommended: CGFloat = 48
    /// base × 1.27 = 44 × 1.27 ≈ 56
    public static let tapAreaComfortable: CGFloat = 56
    /// base × 1.45 = 44 × 1.45 ≈ 64
    public static let tapAreaGenerous: CGFloat = 64

    // ============================================
    // SEMANTIC TOKENS
    /// Use these for UI development
    // ============================================

    public static let colorPrimary = purple300
    public static let colorSuccessStrong = green400
    public static let colorSuccessSubtle = green100
    public static let colorWarningStrong = orange400
    public static let colorWarningSubtle = orange100
    public static let colorErrorStrong = pink400
    public static let colorErrorSubtle = pink100
    public static let colorInfoStrong = teal400
    public static let colorInfoSubtle = teal100
    public static let colorAttention = yellow400
    public static let colorHighlight = yellow300
    public static let colorTech = cyan400
    public static let colorData = cyan300
    public static let colorTextDefault = gray300
    public static let colorTextMuted = gray200
    public static let colorTextSubtle = gray100
    public static let colorContrastOnPrimary = white100
    public static let colorCanvas = white100
    public static let colorBackground = white100
    public static let colorBackgroundPrimarySubtle = purple100
    public static let colorSurface = white200
    public static let colorBorder = gray100
    public static let colorIconDefault = gray200
    public static let colorPrintDefault = black100
    public static let glowNeonPurple = purple500
    public static let glowNeonCyan = cyan500
    public static let glowNeonYellow = yellow500
    public static let glowNeonGreen = green500
    public static let glowNeonPink = pink500
    public static let colorSelectSelectedStrong = cyan400
    public static let colorSelectSelectedSubtle = cyan100
    public static let colorSelectNotSelectedStrong = gray200
    public static let colorSelectNotSelectedSubtle = gray100
    public static let typographyBodySm = Typography(fontSize: fontSize075, lineHeight: lineHeight075, fontFamily: fontFamilyBody, fontWeight: fontWeight400, letterSpacing: letterSpacing100)
    public static let typographyBodyMd = Typography(fontSize: fontSize100, lineHeight: lineHeight100, fontFamily: fontFamilyBody, fontWeight: fontWeight400, letterSpacing: letterSpacing100)
    public static let typographyBodyLg = Typography(fontSize: fontSize125, lineHeight: lineHeight125, fontFamily: fontFamilyBody, fontWeight: fontWeight400, letterSpacing: letterSpacing100)
    public static let typographyH1 = Typography(fontSize: fontSize600, lineHeight: lineHeight600, fontFamily: fontFamilyDisplay, fontWeight: fontWeight700, letterSpacing: letterSpacing100)
    public static let typographyH2 = Typography(fontSize: fontSize500, lineHeight: lineHeight500, fontFamily: fontFamilyDisplay, fontWeight: fontWeight700, letterSpacing: letterSpacing100)
    public static let typographyH3 = Typography(fontSize: fontSize400, lineHeight: lineHeight400, fontFamily: fontFamilyDisplay, fontWeight: fontWeight600, letterSpacing: letterSpacing100)
    public static let typographyH4 = Typography(fontSize: fontSize300, lineHeight: lineHeight300, fontFamily: fontFamilyDisplay, fontWeight: fontWeight600, letterSpacing: letterSpacing100)
    public static let typographyH5 = Typography(fontSize: fontSize200, lineHeight: lineHeight200, fontFamily: fontFamilyDisplay, fontWeight: fontWeight600, letterSpacing: letterSpacing100)
    public static let typographyH6 = Typography(fontSize: fontSize150, lineHeight: lineHeight150, fontFamily: fontFamilyDisplay, fontWeight: fontWeight700, letterSpacing: letterSpacing100)
    public static let typographyCaption = Typography(fontSize: fontSize050, lineHeight: lineHeight050, fontFamily: fontFamilyBody, fontWeight: fontWeight300, letterSpacing: letterSpacing100)
    public static let typographyLegal = Typography(fontSize: fontSize050, lineHeight: lineHeight050, fontFamily: fontFamilyBody, fontWeight: fontWeight400, letterSpacing: letterSpacing100)
    public static let typographyDisplay = Typography(fontSize: fontSize700, lineHeight: lineHeight700, fontFamily: fontFamilyDisplay, fontWeight: fontWeight700, letterSpacing: letterSpacing100)
    public static let typographyButtonSm = Typography(fontSize: fontSize075, lineHeight: lineHeight075, fontFamily: fontFamilyBody, fontWeight: fontWeight500, letterSpacing: letterSpacing100)
    public static let typographyButtonMd = Typography(fontSize: fontSize100, lineHeight: lineHeight100, fontFamily: fontFamilyBody, fontWeight: fontWeight500, letterSpacing: letterSpacing100)
    public static let typographyButtonLg = Typography(fontSize: fontSize125, lineHeight: lineHeight125, fontFamily: fontFamilyBody, fontWeight: fontWeight500, letterSpacing: letterSpacing100)
    public static let typographyInput = Typography(fontSize: fontSize100, lineHeight: lineHeight100, fontFamily: fontFamilyBody, fontWeight: fontWeight400, letterSpacing: letterSpacing100)
    public static let typographyLabelXs = Typography(fontSize: fontSize050, lineHeight: lineHeight050, fontFamily: fontFamilyBody, fontWeight: fontWeight500, letterSpacing: letterSpacing100)
    public static let typographyLabelSm = Typography(fontSize: fontSize075, lineHeight: lineHeight075, fontFamily: fontFamilyBody, fontWeight: fontWeight500, letterSpacing: letterSpacing100)
    public static let typographyLabelMd = Typography(fontSize: fontSize100, lineHeight: lineHeight100, fontFamily: fontFamilyBody, fontWeight: fontWeight500, letterSpacing: letterSpacing100)
    public static let typographyLabelMdFloat = Typography(fontSize: fontSize075, lineHeight: lineHeight075, fontFamily: fontFamilyBody, fontWeight: fontWeight500, letterSpacing: letterSpacing100)
    public static let typographyLabelLg = Typography(fontSize: fontSize125, lineHeight: lineHeight125, fontFamily: fontFamilyBody, fontWeight: fontWeight500, letterSpacing: letterSpacing100)
    public static let typographyCodeSm = Typography(fontSize: fontSize075, lineHeight: lineHeight075, fontFamily: fontFamilyMono, fontWeight: fontWeight400, letterSpacing: letterSpacing100)
    public static let typographyCodeMd = Typography(fontSize: fontSize100, lineHeight: lineHeight100, fontFamily: fontFamilyMono, fontWeight: fontWeight400, letterSpacing: letterSpacing100)
    public static let typographyCodeLg = Typography(fontSize: fontSize125, lineHeight: lineHeight125, fontFamily: fontFamilyMono, fontWeight: fontWeight400, letterSpacing: letterSpacing100)
    public static let shadowNone = Typography(offsetX: shadowOffsetX000, offsetY: shadowOffsetY000, blur: shadowBlurNone, opacity: shadowOpacityNone, color: shadowBlack100)
    public static let shadowContainer = Typography(offsetX: shadowOffsetX000, offsetY: shadowOffsetY100, blur: shadowBlurModerate, opacity: shadowOpacityModerate, color: shadowBlack100)
    public static let shadowNavigation = Typography(offsetX: shadowOffsetX000, offsetY: shadowOffsetY100, blur: shadowBlurSoft, opacity: shadowOpacitySoft, color: shadowBlack100)
    public static let shadowDropdown = Typography(offsetX: shadowOffsetX000, offsetY: shadowOffsetY100, blur: shadowBlurModerate, opacity: shadowOpacityModerate, color: shadowBlack100)
    public static let shadowModal = Typography(offsetX: shadowOffsetX000, offsetY: shadowOffsetY200, blur: shadowBlurDepth200, opacity: shadowOpacityDepth200, color: shadowBlack100)
    public static let shadowToast = Typography(offsetX: shadowOffsetX000, offsetY: shadowOffsetY300, blur: shadowBlurDepth300, opacity: shadowOpacityDepth300, color: shadowBlack100)
    public static let shadowTooltip = Typography(offsetX: shadowOffsetX000, offsetY: shadowOffsetY300, blur: shadowBlurDepth300, opacity: shadowOpacityDepth300, color: shadowBlack100)
    public static let shadowFab = Typography(offsetX: shadowOffsetX300, offsetY: shadowOffsetY400, blur: shadowBlurHard, opacity: shadowOpacityHard, color: shadowBlue100)
    public static let shadowHover = Typography(offsetX: shadowOffsetX000, offsetY: shadowOffsetY100, blur: shadowBlurSoft, opacity: shadowOpacitySoft, color: shadowBlack100)
    public static let shadowSunrise = Typography(offsetX: shadowOffsetXN300, offsetY: shadowOffsetY200, blur: shadowBlurModerate, opacity: shadowOpacityModerate, color: shadowBlue100)
    public static let shadowMorning = Typography(offsetX: shadowOffsetXN150, offsetY: shadowOffsetY200, blur: shadowBlurModerate, opacity: shadowOpacityModerate, color: shadowBlack100)
    public static let shadowNoon = Typography(offsetX: shadowOffsetX000, offsetY: shadowOffsetY200, blur: shadowBlurModerate, opacity: shadowOpacityModerate, color: shadowBlack100)
    public static let shadowDusk = Typography(offsetX: shadowOffsetX150, offsetY: shadowOffsetY200, blur: shadowBlurModerate, opacity: shadowOpacityModerate, color: shadowBlack100)
    public static let shadowSunset = Typography(offsetX: shadowOffsetX300, offsetY: shadowOffsetY200, blur: shadowBlurModerate, opacity: shadowOpacityModerate, color: shadowBlue100)
    public static let opacitySubtle = opacity1100
    public static let opacityMedium = opacity900
    public static let opacityHeavy = opacity600
    public static let opacityGhost = opacity400
    public static let blendHoverDarker = blend200
    public static let blendHoverLighter = blend200
    public static let blendPressedDarker = blend300
    public static let blendFocusSaturate = blend200
    public static let blendDisabledDesaturate = blend300
    public static let blendContainerHoverDarker = blend100
    public static let colorIconOpticalBalance = blend200
    public static let gridGutterXs = space200
    public static let gridGutterSm = space250
    public static let gridGutterMd = space300
    public static let gridGutterLg = space400
    public static let gridMarginXs = space300
    public static let gridMarginSm = space300
    public static let gridMarginMd = space400
    public static let gridMarginLg = space500
    public static let gridGutterNative = space250
    public static let gridMarginNative = space300
    public static let iconStrokeWidth = borderWidth200
    public static let iconSize050: CGFloat = 16 // Icon size calculated from fontSize050 × custom multiplier = 13 × 1.231 = 16px (rounded from 16.003). Uses optical correction multiplier instead of lineHeight050 (1.538) for better balance with small text. | Pairs with: Icon size for caption, legal, labelXs typography (smallest text)
    public static let iconSize075: CGFloat = 20 // Icon size calculated from fontSize075 × lineHeight075 = 14 × 1.429 = 20px (rounded from 20.006) | Pairs with: Icon size for bodySm, buttonSm, labelSm typography
    public static let iconSize100: CGFloat = 24 // Icon size calculated from fontSize100 × lineHeight100 = 16 × 1.5 = 24px | Pairs with: Icon size for bodyMd, buttonMd, labelMd, input typography (standard)
    public static let iconSize125: CGFloat = 28 // Icon size calculated from fontSize125 × lineHeight125 = 18 × 1.556 = 28px (rounded from 28.008) | Pairs with: Icon size for bodyLg, buttonLg, labelLg typography
    public static let iconSize150: CGFloat = 28 // Icon size calculated from fontSize150 × lineHeight150 = 20 × 1.4 = 28px | Pairs with: Icon size for h6 typography (smallest heading)
    public static let iconSize200: CGFloat = 32 // Icon size calculated from fontSize200 × lineHeight200 = 23 × 1.391 = 32px (rounded from 31.993) | Pairs with: Icon size for h5 typography
    public static let iconSize300: CGFloat = 32 // Icon size calculated from fontSize300 × lineHeight300 = 26 × 1.231 = 32px (rounded from 32.006) | Pairs with: Icon size for h4 typography
    public static let iconSize400: CGFloat = 36 // Icon size calculated from fontSize400 × lineHeight400 = 29 × 1.241 = 36px (rounded from 35.989) | Pairs with: Icon size for h3 typography
    public static let iconSize500: CGFloat = 40 // Icon size calculated from fontSize500 × lineHeight500 = 33 × 1.212 = 40px (rounded from 39.996) | Pairs with: Icon size for h2 typography
    public static let iconSize600: CGFloat = 44 // Icon size calculated from fontSize600 × lineHeight600 = 37 × 1.19 = 44px (rounded from 44.03) | Pairs with: Icon size for h1 typography
    public static let iconSize700: CGFloat = 48 // Icon size calculated from fontSize700 × lineHeight700 = 42 × 1.143 = 48px (rounded from 48.006) | Pairs with: Icon size for display typography (hero text)
    // WCAG 2.4.7 Focus Visible
    public static let accessibilityFocusOffset = space025
    // WCAG 2.4.7 Focus Visible
    public static let accessibilityFocusWidth = borderWidth200
    // WCAG 2.4.7 Focus Visible
    public static let accessibilityFocusColor = purple300
    public static let motionFloatLabel = Typography(duration: duration250, easing: easingStandard)
    public static let motionFocusTransition = Typography(duration: duration150, easing: easingStandard)
    public static let motionButtonPress = Typography(duration: duration150, easing: easingAccelerate)
    public static let motionModalSlide = Typography(duration: duration350, easing: easingDecelerate)
    public static let motionSelectionTransition = Typography(duration: duration250, easing: easingStandard)
    public static let borderNone = borderWidth000
    public static let borderDefault = borderWidth100
    public static let borderEmphasis = borderWidth200
    public static let borderHeavy = borderWidth400
    public static let radiusNone = radius000
    public static let radiusSubtle = radius025
    public static let radiusSmall = radius050
    public static let radiusNormal = radius100
    public static let radiusLarge = radius200
    public static let radiusFull = radiusFull
    public static let radiusCircle = radiusHalf
    public static let spaceGroupedNone = space000
    public static let spaceGroupedMinimal = space025
    public static let spaceGroupedTight = space050
    public static let spaceGroupedNormal = space100
    public static let spaceGroupedLoose = space150
    public static let spaceRelatedNone = space000
    public static let spaceRelatedTight = space100
    public static let spaceRelatedNormal = space200
    public static let spaceRelatedLoose = space300
    public static let spaceSeparatedNone = space000
    public static let spaceSeparatedTight = space200
    public static let spaceSeparatedNormal = space300
    public static let spaceSeparatedLoose = space400
    public static let spaceSectionedNone = space000
    public static let spaceSectionedTight = space400
    public static let spaceSectionedNormal = space500
    public static let spaceSectionedLoose = space600
    public static let spaceInset100 = space100
    public static let spaceInset150 = space150
    public static let spaceInset200 = space200
    public static let spaceInset300 = space300
    public static let spaceInset400 = space400
    public static let spaceInsetNone = space000
    public static let spaceInset050 = space050

    // MARK: - Motion Tokens
    // MARK: - Duration Tokens
    
    /// Animation duration values in seconds (TimeInterval)
    public enum Duration {
        /// duration150: 0.15s (150ms)
        public static let duration150: TimeInterval = 0.15
        /// duration250: 0.25s (250ms)
        public static let duration250: TimeInterval = 0.25
        /// duration350: 0.35s (350ms)
        public static let duration350: TimeInterval = 0.35
    }
    
    // MARK: - Easing Tokens
    
    /// Animation easing curves using Animation.timingCurve
    public enum Easing {
        /// easingStandard: Animation.timingCurve(0.4, 0.0, 0.2, 1)
        public static let easingStandard = Animation.timingCurve(0.4, 0.0, 0.2, 1)
        /// easingDecelerate: Animation.timingCurve(0.0, 0.0, 0.2, 1)
        public static let easingDecelerate = Animation.timingCurve(0.0, 0.0, 0.2, 1)
        /// easingAccelerate: Animation.timingCurve(0.4, 0.0, 1, 1)
        public static let easingAccelerate = Animation.timingCurve(0.4, 0.0, 1, 1)
    }
    
    // MARK: - Scale Tokens
    
    /// Transform scale factors (unitless)
    /// When applying to base values, use round() for whole pixels
    public enum Scale {
        /// scale088: 0.88
        public static let scale088: CGFloat = 0.88
        /// scale092: 0.92
        public static let scale092: CGFloat = 0.92
        /// scale096: 0.96
        public static let scale096: CGFloat = 0.96
        /// scale100: 1
        public static let scale100: CGFloat = 1
        /// scale104: 1.04
        public static let scale104: CGFloat = 1.04
        /// scale108: 1.08
        public static let scale108: CGFloat = 1.08
    }
    
    // MARK: - Semantic Motion Tokens
    
    /// Composed motion styles for specific animation contexts
    
    /// Standard motion for label floating up with balanced easing (250ms, standard curve). Used when text input receives focus and label transitions from placeholder to floating position.
    public struct MotionFloatLabel {
        public static let duration = Duration.duration250
        public static let easing = Easing.easingStandard
    }
    
    /// Fast motion for focus state changes with balanced easing (150ms, standard curve). Used when elements receive or lose focus, providing quick visual feedback for user interactions.
    public struct MotionFocusTransition {
        public static let duration = Duration.duration150
        public static let easing = Easing.easingStandard
    }
    
    /// Fast motion for button press feedback with accelerate easing (150ms, accelerate curve). Used for scale transforms during button press, providing immediate tactile response to user input.
    public struct MotionButtonPress {
        public static let duration = Duration.duration150
        public static let easing = Easing.easingAccelerate
    }
    
    /// Deliberate motion for modal entry with decelerate easing (350ms, decelerate curve). Used when modals, drawers, or overlays slide into view, creating a natural entrance effect that settles into place.
    public struct MotionModalSlide {
        public static let duration = Duration.duration350
        public static let easing = Easing.easingDecelerate
    }
    
    /// Standard motion for selection state changes with balanced easing (250ms, standard curve). Used when selectable elements (buttons, list items, checkboxes) transition between selected/unselected states, providing smooth visual feedback for user selections.
    public struct MotionSelectionTransition {
        public static let duration = Duration.duration250
        public static let easing = Easing.easingStandard
    }
    

    // MARK: - Layering Tokens (Z-Index)
    static let zIndexContainer: CGFloat = 1
    static let zIndexNavigation: CGFloat = 2
    static let zIndexDropdown: CGFloat = 3
    static let zIndexModal: CGFloat = 4
    static let zIndexToast: CGFloat = 5
    static let zIndexTooltip: CGFloat = 6
}